"""AI-powered build generation service using Qwen3-8B via Ollama."""
import logging
import json
import re
from typing import Dict, List, Optional, Tuple
from api_clients import TarkovAPIClient
from database import Database
from .context_builder import ContextBuilder

logger = logging.getLogger(__name__)


class AIGenerationService:
    """Service for AI-powered weapon build generation."""
    
    def __init__(
        self, 
        api_client: TarkovAPIClient,
        db: Database,
        ollama_url: str = "http://localhost:11434"
    ):
        self.api = api_client
        self.db = db
        self.context_builder = ContextBuilder(api_client, db)
        self.ollama_url = ollama_url
        self.model = "qwen3:8b"  # Using Qwen3-8B as specified in technical requirements
    
    async def generate_build(
        self,
        user_request: str,
        user_id: int,
        language: str = "ru"
    ) -> Optional[Dict]:
        """
        Generate weapon build based on user request using LLM.
        
        Args:
            user_request: User's natural language request
            user_id: Telegram user ID
            language: User's language (ru/en)
            
        Returns:
            Dict with build information or None if generation failed
        """
        try:
            # Parse user intent
            intent = await self._parse_intent(user_request, language)
            
            # Build context
            context = await self._build_generation_context(intent, user_id, language)
            
            # Generate build via LLM
            prompt = self._create_build_prompt(user_request, context, language)
            
            response = await self._call_ollama(prompt)
            if not response:
                logger.warning("No response from Ollama")
                return None
            
            # Parse response into structured build
            build_data = self._parse_build_response(response, language)
            
            return build_data
            
        except Exception as e:
            logger.error(f"Error generating build: {e}", exc_info=True)
            return None
    
    async def generate_quest_build(
        self,
        quest_name: str,
        user_id: int,
        language: str = "ru"
    ) -> Optional[Dict]:
        """
        Generate build specifically for a quest.
        
        Args:
            quest_name: Name of the quest
            user_id: Telegram user ID
            language: User's language (ru/en)
            
        Returns:
            Dict with build information or None if generation failed
        """
        try:
            # Get quest details
            quest_context = await self.context_builder.build_quest_context(quest_name, language)
            user_context = await self.context_builder.build_user_context(user_id)
            
            prompt = self._create_quest_build_prompt(quest_name, quest_context, user_context, language)
            
            response = await self._call_ollama(prompt)
            if not response:
                return None
            
            build_data = self._parse_build_response(response, language)
            build_data["quest_name"] = quest_name
            
            return build_data
            
        except Exception as e:
            logger.error(f"Error generating quest build: {e}", exc_info=True)
            return None
    
    async def _parse_intent(self, user_request: str, language: str) -> Dict:
        """Parse user intent from request."""
        intent = {
            "type": "custom",  # custom, quest, meta, random
            "weapon_name": None,
            "budget": None,
            "preferences": []
        }
        
        request_lower = user_request.lower()
        
        # Detect quest requests
        quest_keywords = ["–∫–≤–µ—Å—Ç", "quest", "–æ—Ä—É–∂–µ–π–Ω–∏–∫", "gunsmith", "–º–µ—Ö–∞–Ω–∏–∫", "mechanic"]
        if any(kw in request_lower for kw in quest_keywords):
            intent["type"] = "quest"
        
        # Detect meta requests
        meta_keywords = ["–º–µ—Ç–∞", "meta", "–ª—É—á—à", "best", "—Ç–æ–ø", "top"]
        if any(kw in request_lower for kw in meta_keywords):
            intent["type"] = "meta"
        
        # Extract budget
        budget_pattern = r'(\d+)\s*[–∫k–∫]?(?:\s*—Ä—É–±|‚ÇΩ)?'
        budget_matches = re.findall(budget_pattern, request_lower)
        if budget_matches:
            budget_str = budget_matches[0]
            budget_value = int(budget_str)
            # Handle 'k' suffix
            if 'k' in request_lower or '–∫' in request_lower:
                budget_value *= 1000
            intent["budget"] = budget_value
        
        # Extract weapon name (simple heuristic)
        weapon_keywords = [
            "–∞–∫", "ak", "–º4", "m4", "–º—Ä", "mp", "—Å–≤–¥", "svd", "–≤–∞–ª", "val", 
            "–≤—Å–∫", "vsk", "–≤–ø–æ", "vpo", "—Å–∞–π–≥–∞", "saiga", "–≤–µ–ø—Ä—å", "vepr"
        ]
        for keyword in weapon_keywords:
            if keyword in request_lower:
                # Try to extract weapon name around keyword
                words = user_request.split()
                for word in words:
                    if keyword in word.lower():
                        intent["weapon_name"] = word
                        break
        
        # Extract preferences
        if "—ç—Ä–≥–æ–Ω–æ–º–∏–∫–∞" in request_lower or "ergonomic" in request_lower or "ergo" in request_lower:
            intent["preferences"].append("ergonomics")
        if "–æ—Ç–¥–∞—á–∞" in request_lower or "recoil" in request_lower:
            intent["preferences"].append("recoil")
        if "–ø—Ä–∏—Ü–µ–ª" in request_lower or "sight" in request_lower or "scope" in request_lower:
            intent["preferences"].append("sight")
        
        return intent
    
    async def _build_generation_context(
        self, 
        intent: Dict, 
        user_id: int, 
        language: str
    ) -> str:
        """Build context for LLM based on intent."""
        context_parts = []
        
        # User context
        user_ctx = await self.context_builder.build_user_context(user_id)
        context_parts.append(user_ctx)
        
        # Weapon context
        if intent.get("weapon_name"):
            # Search for specific weapon
            weapons = await self.api.search_items(intent["weapon_name"], item_types=["gun"])
            if weapons:
                weapon = weapons[0]
                weapon_ctx = await self.context_builder.build_weapon_context(weapon["id"], language)
                context_parts.append(weapon_ctx)
                
                # Module context
                module_ctx = await self.context_builder.build_modules_context(weapon["id"], language)
                context_parts.append(module_ctx)
        else:
            # General weapon context
            weapon_ctx = await self.context_builder.build_weapon_context(None, language)
            context_parts.append(weapon_ctx)
        
        # Quest context if needed
        if intent["type"] == "quest":
            quest_ctx = await self.context_builder.build_quest_context(None, language)
            context_parts.append(quest_ctx)
        
        return "\n\n---\n\n".join(context_parts)
    
    def _create_build_prompt(self, user_request: str, context: str, language: str) -> str:
        """Create prompt for LLM build generation."""
        if language == "ru":
            system_prompt = """–¢—ã ‚Äî –ù–∏–∫–∏—Ç–∞ –ë—É—è–Ω–æ–≤, –≥–ª–∞–≤–Ω—ã–π —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫ Escape from Tarkov –∏ —ç–∫—Å–ø–µ—Ä—Ç –ø–æ –∏–≥—Ä–µ. 
–¢–≤–æ—è –∑–∞–¥–∞—á–∞ ‚Äî –ø–æ–º–æ–≥–∞—Ç—å –∏–≥—Ä–æ–∫–∞–º —Å–æ–∑–¥–∞–≤–∞—Ç—å –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã–µ —Å–±–æ—Ä–∫–∏ –æ—Ä—É–∂–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –∞–∫—Ç—É–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –∏–∑ tarkov.dev.

–í–ê–ñ–ù–´–ï –ü–†–ê–í–ò–õ–ê:
1. –í—Å–µ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑—É–π –¢–û–õ–¨–ö–û –¥–∞–Ω–Ω—ã–µ –∏–∑ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ (ID –æ—Ä—É–∂–∏—è, –º–æ–¥—É–ª–µ–π, —Ü–µ–Ω—ã)
2. –ì–µ–Ω–µ—Ä–∏—Ä—É–π —Å–±–æ—Ä–∫–∏ —Å —É—á—ë—Ç–æ–º —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å–ª–æ—Ç–æ–≤ (–∫–∞–∂–¥—ã–π –º–æ–¥—É–ª—å –¥–æ–ª–∂–µ–Ω –ø–æ–¥—Ö–æ–¥–∏—Ç—å –∫ —Å–≤–æ–µ–º—É —Å–ª–æ—Ç—É)
3. –£—á–∏—Ç—ã–≤–∞–π –±—é–¥–∂–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω)
4. –°—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä—É–π –æ—Ç–≤–µ—Ç –∏–µ—Ä–∞—Ä—Ö–∏—á–µ—Å–∫–∏: –±–∞–∑–æ–≤–æ–µ –æ—Ä—É–∂–∏–µ ‚Üí –∫–∞–∂–¥—ã–π —Å–ª–æ—Ç ‚Üí –º–æ–¥—É–ª–∏ ‚Üí —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏
5. –î–æ–±–∞–≤–ª—è–π –∫–æ—Ä–æ—Ç–∫–æ–µ –æ–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ –≤—ã–±–æ—Ä–∞ –º–æ–¥—É–ª–µ–π
6. –£–∫–∞–∑—ã–≤–∞–π –∏—Ç–æ–≥–æ–≤—É—é —Å—Ç–æ–∏–º–æ—Å—Ç—å –∏ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å (—Ç–æ—Ä–≥–æ–≤—Ü—ã/–±–∞—Ä–∞—Ö–æ–ª–∫–∞)

–§–û–†–ú–ê–¢ –û–¢–í–ï–¢–ê:
ü§ñ –ù–∏–∫–∏—Ç–∞ –ë—É—è–Ω–æ–≤:
–í–æ—Ç –≤–∞—à–∞ —Å–±–æ—Ä–∫–∞ –¥–ª—è [–û–†–£–ñ–ò–ï]:

1Ô∏è‚É£ **–ë–∞–∑–æ–≤–æ–µ –æ—Ä—É–∂–∏–µ:** [–ù–ê–ó–í–ê–ù–ò–ï] (ID: [ID])
   - –¶–µ–Ω–∞: [–¶–ï–ù–ê] ‚ÇΩ
   - –ë–∞–∑–æ–≤–∞—è —ç—Ä–≥–æ–Ω–æ–º–∏–∫–∞: [–ó–ù–ê–ß–ï–ù–ò–ï]
   - –ë–∞–∑–æ–≤–∞—è –æ—Ç–¥–∞—á–∞: [–ó–ù–ê–ß–ï–ù–ò–ï]
   üìç [–¢–û–†–ì–û–í–ï–¶] L[–£–†–û–í–ï–ù–¨]

2Ô∏è‚É£ **[–°–õ–û–¢ 1]:**
   –∞) [–ú–û–î–£–õ–¨] ‚Äî [–¶–ï–ù–ê] ‚ÇΩ (–≠—Ä–≥–æ–Ω–æ–º–∏–∫–∞: +X, –û—Ç–¥–∞—á–∞: -Y)
      üìç [–¢–û–†–ì–û–í–ï–¶] L[–£–†–û–í–ï–ù–¨] –∏–ª–∏ Flea Market

3Ô∏è‚É£ **[–°–õ–û–¢ 2]:**
   –∞) [–ú–û–î–£–õ–¨] ‚Äî [–¶–ï–ù–ê] ‚ÇΩ
      üìç [–¢–û–†–ì–û–í–ï–¶] L[–£–†–û–í–ï–ù–¨] –∏–ª–∏ Flea Market

...

üìä **–•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏:**
   - –≠—Ä–≥–æ–Ω–æ–º–∏–∫–∞: [–ò–¢–û–ì]
   - –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞—è –æ—Ç–¥–∞—á–∞: [–ò–¢–û–ì]
   - –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞—è –æ—Ç–¥–∞—á–∞: [–ò–¢–û–ì]

üí∞ **–ò—Ç–æ–≥–æ:** [–°–£–ú–ú–ê] ‚ÇΩ

üí° **–û–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ:** [1-2 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –ø–æ—á–µ–º—É –≤—ã–±—Ä–∞–Ω—ã —ç—Ç–∏ –º–æ–¥—É–ª–∏]
"""
        else:
            system_prompt = """You are Nikita Buyanov, lead developer of Escape from Tarkov and game expert.
Your task is to help players create optimal weapon builds based on actual data from tarkov.dev.

IMPORTANT RULES:
1. ONLY use data from provided context (weapon IDs, module IDs, prices)
2. Generate builds considering slot compatibility (each module must fit its slot)
3. Consider user's budget (if specified)
4. Structure response hierarchically: base weapon ‚Üí each slot ‚Üí modules ‚Üí stats
5. Add brief reasoning for module choices
6. Include total cost and availability (traders/flea)

RESPONSE FORMAT:
ü§ñ Nikita Buyanov:
Here's your build for [WEAPON]:

1Ô∏è‚É£ **Base weapon:** [NAME] (ID: [ID])
   - Price: [PRICE] ‚ÇΩ
   - Base ergonomics: [VALUE]
   - Base recoil: [VALUE]
   üìç [TRADER] L[LEVEL]

2Ô∏è‚É£ **[SLOT 1]:**
   a) [MODULE] ‚Äî [PRICE] ‚ÇΩ (Ergonomics: +X, Recoil: -Y)
      üìç [TRADER] L[LEVEL] or Flea Market

3Ô∏è‚É£ **[SLOT 2]:**
   a) [MODULE] ‚Äî [PRICE] ‚ÇΩ
      üìç [TRADER] L[LEVEL] or Flea Market

...

üìä **Stats:**
   - Ergonomics: [TOTAL]
   - Vertical recoil: [TOTAL]
   - Horizontal recoil: [TOTAL]

üí∞ **Total:** [SUM] ‚ÇΩ

üí° **Reasoning:** [1-2 sentences why these modules were chosen]
"""
        
        prompt = f"""{system_prompt}

–î–ê–ù–ù–´–ï –ò–ó TARKOV.DEV:
{context}

–ó–ê–ü–†–û–° –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–Ø:
{user_request}

–°–≥–µ–Ω–µ—Ä–∏—Ä—É–π —Å–±–æ—Ä–∫—É –Ω–∞ –æ—Å–Ω–æ–≤–µ —ç—Ç–∏—Ö –¥–∞–Ω–Ω—ã—Ö:"""
        
        return prompt
    
    def _create_quest_build_prompt(
        self, 
        quest_name: str, 
        quest_context: str, 
        user_context: str,
        language: str
    ) -> str:
        """Create prompt specifically for quest builds."""
        if language == "ru":
            prompt = f"""–¢—ã ‚Äî –ù–∏–∫–∏—Ç–∞ –ë—É—è–Ω–æ–≤, —ç–∫—Å–ø–µ—Ä—Ç –ø–æ –∫–≤–µ—Å—Ç–∞–º Escape from Tarkov.
–°–æ–∑–¥–∞–π —Å–±–æ—Ä–∫—É –¥–ª—è –∫–≤–µ—Å—Ç–∞ "{quest_name}".

–í–ê–ñ–ù–û: –°–±–æ—Ä–∫–∞ –¥–æ–ª–∂–Ω–∞ –¢–û–ß–ù–û —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞—Ç—å —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º –∫–≤–µ—Å—Ç–∞ (–∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ –º–æ–¥—É–ª–∏, —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏).

–ò–ù–§–û–†–ú–ê–¶–ò–Ø –û –ö–í–ï–°–¢–ï:
{quest_context}

{user_context}

–°–æ–∑–¥–∞–π —Å–±–æ—Ä–∫—É, –∫–æ—Ç–æ—Ä–∞—è –≤—ã–ø–æ–ª–Ω–∏—Ç –≤—Å–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è –∫–≤–µ—Å—Ç–∞:"""
        else:
            prompt = f"""You are Nikita Buyanov, expert on Escape from Tarkov quests.
Create a build for quest "{quest_name}".

IMPORTANT: Build must EXACTLY match quest requirements (specific modules, stats).

QUEST INFORMATION:
{quest_context}

{user_context}

Create a build that fulfills all quest requirements:"""
        
        return prompt
    
    async def _call_ollama(self, prompt: str) -> Optional[str]:
        """Call Ollama API to generate response."""
        try:
            import aiohttp
            
            async with aiohttp.ClientSession() as session:
                payload = {
                    "model": self.model,
                    "prompt": prompt,
                    "stream": False,
                    "options": {
                        "temperature": 0.7,
                        "top_p": 0.9,
                        "max_tokens": 2048
                    }
                }
                
                async with session.post(
                    f"{self.ollama_url}/api/generate",
                    json=payload,
                    timeout=aiohttp.ClientTimeout(total=60)
                ) as response:
                    if response.status != 200:
                        logger.error(f"Ollama API error: {response.status}")
                        return None
                    
                    result = await response.json()
                    return result.get("response", "")
        
        except Exception as e:
            logger.error(f"Error calling Ollama: {e}", exc_info=True)
            return None
    
    def _parse_build_response(self, response: str, language: str) -> Dict:
        """Parse LLM response into structured build data."""
        build_data = {
            "text": response,
            "weapon": None,
            "modules": [],
            "stats": {},
            "total_cost": None,
            "reasoning": None
        }
        
        try:
            # Extract weapon name
            weapon_pattern = r"(?:Base weapon|–ë–∞–∑–æ–≤–æ–µ –æ—Ä—É–∂–∏–µ):\s*\*\*([^\*]+)\*\*"
            weapon_match = re.search(weapon_pattern, response, re.IGNORECASE)
            if weapon_match:
                build_data["weapon"] = weapon_match.group(1).strip()
            
            # Extract total cost
            cost_pattern = r"(?:Total|–ò—Ç–æ–≥–æ):\s*([0-9,]+)\s*‚ÇΩ"
            cost_match = re.search(cost_pattern, response)
            if cost_match:
                cost_str = cost_match.group(1).replace(",", "")
                build_data["total_cost"] = int(cost_str)
            
            # Extract stats
            ergo_pattern = r"(?:Ergonomics|–≠—Ä–≥–æ–Ω–æ–º–∏–∫–∞):\s*([0-9]+)"
            ergo_match = re.search(ergo_pattern, response)
            if ergo_match:
                build_data["stats"]["ergonomics"] = int(ergo_match.group(1))
            
            recoil_v_pattern = r"(?:Vertical recoil|–í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞—è –æ—Ç–¥–∞—á–∞):\s*([0-9]+)"
            recoil_v_match = re.search(recoil_v_pattern, response)
            if recoil_v_match:
                build_data["stats"]["recoil_vertical"] = int(recoil_v_match.group(1))
            
            # Extract reasoning
            reasoning_pattern = r"(?:Reasoning|–û–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ):\s*(.+?)(?:\n\n|$)"
            reasoning_match = re.search(reasoning_pattern, response, re.DOTALL)
            if reasoning_match:
                build_data["reasoning"] = reasoning_match.group(1).strip()
        
        except Exception as e:
            logger.error(f"Error parsing build response: {e}")
        
        return build_data
    
    async def check_ollama_available(self) -> bool:
        """Check if Ollama service is available."""
        try:
            import aiohttp
            
            async with aiohttp.ClientSession() as session:
                async with session.get(
                    f"{self.ollama_url}/api/tags",
                    timeout=aiohttp.ClientTimeout(total=5)
                ) as response:
                    return response.status == 200
        
        except Exception as e:
            logger.debug(f"Ollama not available: {e}")
            return False
